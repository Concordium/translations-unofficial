.. _contract-instances-ko:

========================
스마트 계약 인스턴스입니다.
========================

.. todo::

   - 스마트 계약과 관련된 인스턴스가 모듈과 어떻게 관련되는지 명확히 설명합니다(예: 현재 인스턴스는 모듈 + 상태이지만 아래 그림은 인스턴스를 계약 + 상태로 표시).
   - 스마트 계약 모듈을 (자체 개념으로 또는 Wasm 모듈로) 정확히 어떻게 정의해야 하는지, 그리고 이 모듈에 대해 이야기해야 하는지 결정합니다.
   - 구체적인 코드 예시가 있어야 하는지, Washm 또는 Rust에 있어야 하는지, 아니면 유사 코드여야 하는지 결정합니다.
   - 모듈과 인스턴스 간의 관계를 설명하는 그림을 고려해 보십시오.

**스마트 계약 인스턴스** 는 특정 상태 및 GTU 토큰의 양이 포함된 스마트 계약 모듈입니다.
동일한 모듈에서 여러 개의 스마트 계약 인스턴스를 생성할 수 있습니다.
예를 들어, :ref:'옥션 <Auction-ko> 계약의 경우, 각각 특정 품목에 대한 입찰을 전담하는 여러 가지 사례가 있을 수 있으며, 각 항목이 해당 참가자와 함께 참여할 수 있습니다.

스마트 계약 인스턴스는 스마트 계약 모듈에서 요청 된 기능을 호출하는``init`` 트랜잭션을 통해 배포 된 :ref:`스마트 계약 모듈 <contract-module-ko>` 에서 생성 될 수 있습니다.
이 함수는 매개 변수를 취할 수 있습니다.
최종 결과는 인스턴스의 초기 스마트 계약 상태 여야합니다.

.. note::

   스마트 계약 인스턴스를 흔히 *인스턴스* 라고 합니다.

.. graphviz::
   :align: center
   :caption: Example of smart contract module containing two smart contracts:
             Escrow and Crowdfunding. Each contract has two instances.

   digraph G {
       rankdir="BT"

       subgraph cluster_0 {
           label = "Module";
           labelloc=b;
           node [fillcolor=white, shape=note]
           "Crowdfunding";
           "Escrow";
       }

       subgraph cluster_1 {
           label = "Instances";
           style=dotted;
           node [shape=box, style=rounded]
           House;
           Car;
           Gadget;
           Boardgame;
       }

       House:n -> Escrow;
       Car:n -> Escrow;
       Gadget:n -> Crowdfunding;
       Boardgame:n -> Crowdfunding;
   }

스마트 계약 인스턴스의 상태입니다.
===========================================

스마트 계약 인스턴스의 상태는 사용자 정의 상태와 계약이 보유하는 GTU의 양, 즉 *잔액* 의 두 부분으로 구성됩니다.
상태를 언급 할 때 일반적으로 사용자 정의 상태 만 의미합니다.
GTU 금액을 별도로 취급하는 이유는 GTU는 네트워크 규칙에 따라 사용하고받을 수 있기 때문입니다. 예를 들어 계약은 GTU 토큰을 생성하거나 파괴 할 수 없습니다.

.. _contract-instances-init-on-chain-ko:

체인에서 스마트 계약을 인스턴스화합니다.
=======================================

모든 스마트 계약에는 스마트 계약 인스턴스를 만드는 기능이 포함되어야 합니다. 이러한 기능을 *init function* 라고 합니다.

스마트 계약 인스턴스를 생성하기 위해 계정이 배포된 스마트 계약 모듈과 인스턴스화에 사용할 init 기능의 이름을 참조한 특수 트랜잭션을 전송합니다.

트랜잭션에는 스마트 계약 인스턴스의 균형에 추가되는 GTU도 포함될 수 있습니다.
함수에 대한 매개 변수는 바이트 배열 형식으로 트랜잭션의 일부로 제공됩니다.

요약하자면, 트랜잭션에는 다음이 포함됩니다.

- 스마트 계약 모듈을 참조하십시오.
- init 함수의 이름입니다.
- init 함수에 대한 파라미터입니다.
- 인스턴스의 GTU 양입니다.

init 함수는 해당 매개 변수를 사용하여 새 인스턴스를 생성하지 않으려는 신호를 보낼 수 있습니다.
init 함수가 매개 변수를 수락하면 인스턴스의 초기 상태와 해당 잔액을 설정합니다.
인스턴스에는 체인의 주소가 지정되고 트랜잭션을 보낸 계정이 인스턴스의 소유자가 됩니다.
함수가 거부하면 인스턴스가 생성되지 않고 인스턴스 생성을 시도하기 위한 트랜잭션만 체인에 표시됩니다.

.. seealso::

   실제로 계약을 초기화하는 방법에 대한 자세한 내용은 :ref:`initialize-contract-ko` 가이드

인스턴스 상태
===============

모든 스마트 계약 인스턴스는 자체 상태를 유지하며, 이는 온체인에서 바이트 배열로 표시됩니다. 인스턴스는 호스트 환경에서 제공하는 기능을 사용하여 상태를 읽고 쓰고 크기를 조정합니다.

.. seealso::

   이러한 함수에 대한 참조는 :ref:`host-functions-state` 를 참조하십시오.

스마트 계약 상태는 크기가 제한되어 있습니다. 현재 스마트 계약 상태의 한도는 16KiB입니다.

.. seealso::

   이에 대한 자세한 내용은 :ref:`resource-accounting` 을 확인하십시오.

인스턴스와 상호 작용합니다.
===================================

스마트 계약은 *수신 기능* 이라고하는 인스턴스와 상호 작용하기 위해 0 개 이상의 기능을 노출 할 수 있습니다.

init 함수와 마찬가지로 수신 함수는 트랜잭션을 사용하여 트리거됩니다. 트랜잭션에는 계약에 대한 GTU의 일부와 바이트 형식의 함수에 대한 인수가 포함됩니다.

요약하자면, 스마트 계약 상호작용을 위한 트랜잭션에는 다음이 포함됩니다.

- 스마트 계약 인스턴스에 대한 주소입니다.
- 수신 기능의 이름입니다.
- 수신 함수에 대한 매개 변수입니다.
- 인스턴스의 GTU 양입니다.

.. _contract-instance-actions-ko:

이벤트 로깅
====================

.. todo::

   이벤트가 무엇인지, 이벤트가 유용한 이유를 설명합니다.
   "이벤트에 대한 모니터" 를 다시 구문/명료하게 합니다.

이벤트는 스마트 계약 기능을 실행하는 동안 기록 할 수 있습니다. 이것은 수신 기능을 모두 초기화의 경우입니다.
로그는 오프 체인 사용을 위해 설계되었으므로 체인 외부의 행위자가 이벤트를 모니터링하고 이에 대응할 수 있습니다.
로그는 스마트 계약 또는 체인의 다른 행위자가 액세스 할 수 없습니다. 호스트 환경에서 제공하는 기능을 사용하여 이벤트를 기록 할 수 있습니다.

.. seealso::

   이 함수에 대한 참조는 :ref:`host-functions-log` 를 참조하십시오.

이러한 이벤트 로그는 제빵사가 보존하고 트랜잭션 요약에 포함됩니다.

이벤트 로깅에는 계약 상태에 쓰는 비용과 유사한 관련 비용이 있습니다.
대부분의 경우 비용을 줄이기 위해 몇 바이트만 기록하는 것이 타당합니다.

.. _action-descriptions-ko:

조치 설명
===================

수신 함수는 체인의 호스트 환경에서 실행할 *행동에 대한 설명* 을 반환합니다.

계약에서 발생할 수 있는 조치는 다음과 같습니다.

- **받아들이** 는 항상 성공하는 원시적인 작업입니다.
- GTU의 **단순 전송** 입니다.
- **보내기** : 지정한 스마트 계약 인스턴스의 수신 기능을 호출하고 선택적으로 송신 인스턴스에서 수신 인스턴스로 일부 GTU를 전송합니다.

작업이 실행되지 않으면 수신 기능이 되돌아가서 인스턴스의 상태와 균형은 변경되지 않습니다. 그런데요.

- (실패한) 수신 기능을 트리거하는 트랜잭션이 체인에 계속 추가됩니다.
- 실패한 조치의 실행비용을 포함한 거래비용은 발송계좌에서 차감됩니다.

여러 작업 설명을 처리하는 중입니다.
---------------------------------------

**and** 조합을 사용하여 작업 설명을 연결할 수 있습니다.
동작 설명 시퀀스``A`` **및** ``B``

1)``A`` 를 실행합니다.
2)``A`` 가 성공하면``B`` 를 실행합니다.
3)``B`` 가 실패하면 전체 작업 시퀀스가 실패하고``A`` 의 결과가 되돌립니다.

오류 처리
--------------------

**or** 조합기를 사용하여 이전 작업이 실패한 경우 작업을 실행합니다.
작업 설명``A`` **or** ``B``

1)``A`` 를 실행합니다.
2)``A``가 성공하면 실행을 중지합니다.
3)``A`` 가 실패하면 ``B`` 를 실행합니다.

.. graphviz::
   :align: center
   :caption: Example of an action description, which tries to transfer to Alice
             and then Bob, if any of these fails, it will try to transfer to
             Charlie instead.

   digraph G {
       node [color=transparent]
       or1 [label = "Or"];
       and1 [label = "And"];
       transA [label = "Transfer x to Alice"];
       transB [label = "Transfer y to Bob"];
       transC [label = "Transfer z to Charlie"];

       or1 -> and1;
       and1 -> transA;
       and1 -> transB;
       or1 -> transC;
   }

.. seealso::

   액션을 만드는 방법에 대한 참조는 :ref:`host-functions-actions` 를 참조하세요.

전체 작업 트리는 **자동으로** 실행되며 모든 관련 인스턴스 및 계정에 대한 업데이트로 이어 지거나 제거되는 경우 실행에 대한 지불로 이어지지 만 다른 변경 사항은 없습니다.
시작 트랜잭션을 보낸 계정은 전체 트리의 실행 비용을 지불합니다.
