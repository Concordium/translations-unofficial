.. _Rust: https://www.rust-lang.org/
.. _Cargo: https://doc.rust-lang.org/cargo/
.. _rust-analyzer: https://github.com/rust-analyzer/rust-analyzer

.. _compile-module:

======================================================
Компиляция модуля смарт-контракта, написанного в Rust
======================================================

Это руководство покажет, как скомпилировать модуль смарт-контракта, написанного в Rust, в модуль Wasm.

Подготовка
===========

Убедитесь, что Rust и Cargo установлены, а также имеется цель ``wasm32-unknown-unknown``
вместе с ``cargo-concordium`` и исходным кодом Rust для модуля смарт-контракта, который нужно скомпилировать.

.. seealso::

   Инструкция по установке инструментов разработчика: :ref:`setup-tools`.

Компиляция в Wasm
===================

Чтобы помочь в сборке модулей смарт-контрактов и получить преимущество от использования возможностей, таких как :ref:`contract schemas <contract-schema>`, мы рекомендуем использовать утилиту
``cargo-concordium`` для сборки смарт-контрактов, написанных в Rust_ .

Чтобы скомпилировать смарт-контракт, выполните команду:

.. code-block:: console

   $cargo concordium build

Она использует Cargo_ для создания сборки, но при этом выполняет дополнительную оптимизацию результата.

.. seealso::

   Для сборки схемы для модуля смарт-контракта, перейдите по ссылке :ref:`further
   preparation is required <build-schema>`.

.. note::

   Можно также запустить компиляцию с помощью Cargo_ напрямую, выполнив команду:

   .. code-block:: console

      $cargo build --target=wasm32-unknown-unknown [--release]

   Заметим, что даже с параметром ``--release`` , созданный модуль Wasm содержит отладочную информацию.

Удаление из сборки информации о хосте
=======================================

Скомпилированный модуль Wasm может содержать информацию хост-машины, создавшей двоичный код, такую как абсолютный путь к директории ``.cargo`` .

Для большинства людей это не является секретной информацией, но, тем не менее, важно об этом знать.

Под Linux пути можно проверять с помощью команды:

.. code-block:: console

   strings contract.wasm | grep /home/

.. rubric:: Решение

Идеальным решением может стать удаление этого пути целиком, но, к сожалению, это не является такой уж простой задачей, как правило.

Можно обойти эту проблему с помощью флага ``--remap-path-prefix``
при компиляции контракта. В Unix-подобных системах этот флаг можно передать непосредственно через обращение к ``cargo concordium``, используя переменную окружения ``RUSTFLAGS`` :

.. code-block:: console

   $RUSTFLAGS="--remap-path-prefix=$HOME=" cargo concordium build

которая заменит пользовательский home path пустой строкой. Другие пути не могут быть отображены похожим образом. Вообще, использование ``--remap-path-prefix=from=to``
будет отображать ``from`` в ``to`` в начале любого встроенного пути.

Этот флаг может быть также перманентно установлен в конфигурационном файле ``.cargo/config`` контейнера, в секции build:

.. code-block:: toml

   [build]
   rustflags = ["--remap-path-prefix=/home/<user>="]

где `<user>` следует заменить на пользовательскую сборку Wasm-модуля.

Предостережения
------------------

Решение, приведённое выше, не устранит проблему, если компонент ``rust-src`` установлен для Rust-тулчейна.
Этот компонент требуется некоторым утилитам Rust, таким как  rust-analyzer_.

.. seealso::

   Тема, освещающая эту проблему с ``--remap-path-prefix`` и ``rust-src``
   https://github.com/rust-lang/rust/issues/73167
