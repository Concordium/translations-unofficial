.. _contract-instances-ru:

===========================
Экземпляры смарт-контрактов
===========================

.. todo::

   - Разъяснить, как экземпляры связаны со смарт-контрактами и модулями
     (например, прямо сейчас говорится, что экземпляр - это модуль + состояние, но
     рисунок ниже показывает экземпляры как контракты + состояние).
   - Решить, как именно мы должны определять модули смарт-контрактов (как отдельную концепцию
     или как модули Wasm), и стоит ли вообще о них говорить.
   - Решить, нужен ли нам конкретный пример кода, и должен ли он быть
     на Wasm или Rust или, возможно, в псевдокоде.
   - Предоставить картину, объясняющую взаимосвязь между модулями и экземплярами.

**Экземпляр смарт-контракта** это модуль смарт-контракта вместе с конкретным состоянием
и количеством GTU токенов. Из одного модуля можно создать несколько экземпляров смарт-контрактов.
Например, для контракта :ref:`аукциона <auction-ru>` может быть несколько экземпляров,
каждый из которых предназначен для ставок на конкретный товар и со своими участниками.

Экземпляры смарт-контрактов могут быть созданы из развернутого :ref:`модуля
смарт-контракта <contract-module-ru>` через вызов ``init`` транзакции, которая вызывает необходимую
функцию в модуле смарт-контракта. Эта функция может принимать параметр.
Конечный результат должен являться начальным состоянием экземпляра смарт-контракта.

.. note::

   Экземпляр смарт-контракта часто называют просто *экземпляр*.

.. graphviz::
   :align: center
   :caption: Example of smart contract module containing two smart contracts:
             Escrow and Crowdfunding. Each contract has two instances.

   digraph G {
       rankdir="BT"

       subgraph cluster_0 {
           label = "Module";
           labelloc=b;
           node [fillcolor=white, shape=note]
           "Crowdfunding";
           "Escrow";
       }

       subgraph cluster_1 {
           label = "Instances";
           style=dotted;
           node [shape=box, style=rounded]
           House;
           Car;
           Gadget;
           Boardgame;
       }

       House:n -> Escrow;
       Car:n -> Escrow;
       Gadget:n -> Crowdfunding;
       Boardgame:n -> Crowdfunding;
   }

Состояние экземпляра смарт-контракта
====================================

Состояние экземпляра смарт-контракта состоит из двух частей: определяемого
пользователем состояния и суммы GTU, удерживаемой контрактом, то есть
его *баланса*. Когда мы говорим о состоянии, мы обычно имеем в виду только определяемое
пользователем состояние. Причина, по которой количество GTU обрабатывается отдельно,
заключается в том, что GTU может быть потрачен и получен только в соответствии с правилами
сети, например, контракты не могут создавать или уничтожать токены GTU.

.. _contract-instances-init-on-chain-ru:

Создание смарт-контракта в сети
===============================

Каждый смарт-контракт должен содержать функцию для создания экземпляров смарт-контракта.
Такая функция называется *функцией инициализации*.

Чтобы создать экземпляр смарт-контракта, учетная запись отправляет специальную транзакцию
со ссылкой на развернутый модуль смарт-контракта и именем init-функции,
которая будет использоваться для создания экземпляра.

Транзакция также может включать количество GTU, которое добавляется к балансу экземпляра
смарт-контракта. Параметр функции предоставляется как часть транзакции в виде массива байтов.

Подводя итог, транзакция включает:

- Ссылку на модуль смарт-контракта.
- Имя функции инициализации.
- Параметр функции инициализации.
- Количество GTU для экземпляра.

Функция init может уведомить о том, что не может создать новый экземпляр с этими
параметрами. Если init-функция принимает параметры, она устанавливает начальное состояние
экземпляра и его баланс. Экземпляру дается адрес в сети, и учетная запись, отправившая
транзакцию, становится владельцем экземпляра. Если функция отклоняет параметры, экземпляр
не создается, и в сети видна только транзакция с попыткой создания экземпляра.

.. seealso::

   См. руководство :ref:`initialize-contract-ru`, чтобы узнать, как инициализировать
   контракт практически.

Состояние экземпляра
====================

Каждый экземпляр смарт-контракта имеет собственное состояние, которое представлено в сети
как массив байтов. Экземпляр использует функции, предоставляемые средой, для чтения,
записи и изменения размера состояния.

.. seealso::

   См. :ref:`host-functions-state` для справки по этим функциям.

Состояние смарт-контракта ограничено по размеру. В настоящее время ограничение на состояние
смарт-контракта составляет 16KiB.

.. seealso::

   См. :ref:`resource-accounting`, чтобы узнать больше об этом.

Взаимодействие с экземпляром
============================

Смарт-контракт может предоставлять ноль или более функций для взаимодействия с
экземпляром, называемых *принимающие функции*.

Как и в случае с init-функциями , receive-функции запускаются с помощью транзакций,
которые содержат некоторое количество GTU для контракта и аргумент функции в виде байтов.

Подводя итог, транзакция для взаимодействия смарт-контракта включает в себя:

- Адрес экземпляра смарт-контракта.
- Имя receive-функции.
- Параметр receive-функции.
- Количество GTU для экземпляра.

.. _contract-instance-actions-ru:

Логирование событий
===================

.. todo::

   Объяснить, что такое события и почему они полезны.
   Перефразировать/уточнить "следить за событиями".

События могут логироваться во время выполнения функций смарт-контракта. Это касается
как init-функций, так и receive-функций. Журналы логов предназначены для использования
вне сети, чтобы участники за пределами сети могли отслеживать события и реагировать на них.
Журналы логов недоступны для смарт-контрактов или любого другого участника в сети. События могут
регистрироваться с помощью функции, предоставляемой средой.

.. seealso::

   См. :ref:`host-functions-log` для справки об этой функции.

Эти журналы событий сохраняются бекерами и включаются в сводки транзакций.

Регистрация события имеет некоторую стоимость, аналогично затратам на запись состояния контракта.
В большинстве случаев для снижения затрат имеет смысл записать в журнал только несколько байтов.

.. _action-descriptions-ru:

Описание действий
=================

Receive-функция возвращает *описание действий*, которые должны выполняться средой в сети.

Возможные действия, которые может произвести контракт:

- **Принятие**: примитивное действие, которое всегда выполняется успешно.
- **Простой перенос** GTU с экземпляра на указанный аккаунт.
- **Отправка**: вызов receive-функции указанного экземпляра смарт-контракта и, при желании,
  передача некоторых GTU из экземпляра-отправителя в экземпляр-получатель.

Если действие не выполняется, receive-функция отменяется, оставляя состояние и баланс
экземпляра без изменений. Однако,

- транзакция, которая запускает (неудачную) receive-функцию, все еще добавляется в цепочку, и
- стоимость транзакции, включая стоимость выполнения неудавшегося действия, вычитается
  из учетной записи отправителя.

Обработка нескольких действий
-----------------------------

Вы можете описать несколько действий сети с использованием **and** комбинатора.
Описание действия ``A`` **and** ``B``:

1) Выполняется ``A``.
2) В случае успеха ``A``, выполняется ``B``.
3) В случае неудачи ``B`` вся последовательность действий отклоняется (и результат ``A`` отменяется).

Обработка ошибок
----------------

Можно использовать комбинатор **or** для выполнения действия, если предыдущее действие не выполнилось.
Описание действия ``A`` **or** ``B``:

1) Выполняется ``A``.
2) В случае успеха ``A``, выполнение прекращается.
3) В случае неудачи ``A``, выполняется ``B``.

.. graphviz::
   :align: center
   :caption: Example of an action description, which tries to transfer to Alice
             and then Bob, if any of these fails, it will try to transfer to
             Charlie instead.

   digraph G {
       node [color=transparent]
       or1 [label = "Or"];
       and1 [label = "And"];
       transA [label = "Transfer x to Alice"];
       transB [label = "Transfer y to Bob"];
       transC [label = "Transfer z to Charlie"];

       or1 -> and1;
       and1 -> transA;
       and1 -> transB;
       or1 -> transC;
   }

.. seealso::

   См. :ref:`host-functions-actions` для справки о том, как создавать
   действия.

Все дерево действий выполняется **атомарно**, и либо приводит к обновлению всех соответствующих
экземпляров и учетных записей, либо, в случае отклонения выполнения, производится оплата за выполнение,
но без других изменений. Учетная запись, отправившая инициирующую транзакцию, оплачивает
выполнение всего дерева действий.
