.. _contract-instances-ru:

===========================
Экземпляры смарт-контрактов
===========================

.. todo::

   - Clarify how instances relate to smart contracts relate to modules
     (e.g., right now it says that an instance is a module + state but the
     picture below shows instances as contracts + state).
   - Decide how exactly we should define smart-contract modules (as its own concept
     or as Wasm modules), and whether we should talk about them at all.
   - Decide whether we should have a concrete code example, and whether it should
     be in Wasm or Rust or perhaps pseudocode.
   - Consider having a picture that explains the relationship between modules and instances.

**Экземпляр смарт-контракта** это модуль смарт-контракта вместе с конкретным состоянием
и количеством GTU токенов. Из одного модуля можно создать несколько экземпляров смарт-контрактов.
Например, для контракта :ref:`auction <auction>` может быть несколько экземпляров,
каждый из которых предназначен для ставок на конкретный товар и со своими участниками.

Экземпляры смарт-контрактов могут быть созданы из развернутого :ref:`smart contract
module<contract-module-ru>` через вызов ``init`` транзакции, которая вызывает необходимую
функцию в модуле смарт-контракта. Эта функция может принимать параметр.
Конечный результат должен являться начальным состоянием экземпляра смарт-контракта.

.. note::

   Экземпляр смарт-контракта часто называют просто *экземпляр*.

.. graphviz::
   :align: center
   :caption: Example of smart contract module containing two smart contracts:
             Escrow and Crowdfunding. Each contract has two instances.

   digraph G {
       rankdir="BT"

       subgraph cluster_0 {
           label = "Module";
           labelloc=b;
           node [fillcolor=white, shape=note]
           "Crowdfunding";
           "Escrow";
       }

       subgraph cluster_1 {
           label = "Instances";
           style=dotted;
           node [shape=box, style=rounded]
           House;
           Car;
           Gadget;
           Boardgame;
       }

       House:n -> Escrow;
       Car:n -> Escrow;
       Gadget:n -> Crowdfunding;
       Boardgame:n -> Crowdfunding;
   }

Состояние экземпляра смарт-контракта
====================================

Состояние экземпляра смарт-контракта состоит из двух частей: определяемого
пользователем состояния и количества GTU, которое удерживает контрактом, то есть
его *баланса*. Когда мы говорим о состоянии, мы обычно имеем в виду только определяемое
пользователем состояние. Причина, по которой количество GTU обрабатывается отдельно,
заключается в том, что GTU можно тратить и получать только в соответствии с правилами
сети, например, контракты не могут создавать или уничтожать токены GTU.

.. _contract-instances-init-on-chain-ru:

Создание смарт-контракта в сети
===============================

Каждый смарт-контракт должен содержать функцию для создания экземпляров смарт-контракта.
Такая функция называется *функцией инициализации*.

Чтобы создать экземпляр смарт-контракта, учетная запись отправляет специальную транзакцию
со ссылкой на развернутый модуль смарт-контракта и именем функции init,
которая будет использоваться для создания экземпляра.

Транзакция также может включать количество GTU, которое добавляется к балансу экземпляра
смарт-контракта. Параметр функции предоставляется как часть транзакции в виде массива байтов.

Подводя итог, транзакция включает:

- Ссылку на модуль смарт-контракта.
- Имя функции инициализации.
- Параметр функции инициализации.
- Количество GTU для экземпляра.

Функция init может уведомить о том, что не желает создавать новый экземпляр с этими
параметрами. Если функция init принимает параметры, она устанавливает начальное состояние
экземпляра и его баланс. Экземпляру дается адрес в сети, и учетная запись, отправившая
транзакцию, становится владельцем экземпляра. Если функция отклоняет параметры, экземпляр
не создается, и в сети видна только транзакция для попытки создания экземпляра.

.. seealso::

   See :ref:`initialize-contract-ru` guide for how to initialize a
   contract in practice.

Состояние экземпляра
====================

Каждый экземпляр смарт-контракта имеет собственное состояние, которое представлено в сети
как массив байтов. Экземпляр использует функции, предоставляемые средой, для чтения,
записи и изменения размера состояния.

.. seealso::

   See :ref:`host-functions-state` for a reference of these functions.

Состояние смарт-контракта ограничено по размеру. В настоящее время ограничение на состояние
смарт-контракта составляет 16KiB.

.. seealso::

   Check out :ref:`resource-accounting` for more on this.

Взаимодействие с экземпляром
============================

Смарт-контракт может предоставлять ноль или более функций для взаимодействия с
экземпляром, называемых *принимающие функции*.

Как и в случае с функциями init, принимающие функции запускаются с помощью транзакций,
которые содержат некоторое количество GTU для контракта и аргумент функции в виде байтов.

Подводя итог, транзакция для взаимодействия смарт-контракта включает в себя:

- Адрес экземпляра смарт-контракта.
- Имя принимающей функции.
- Параметр принимающией функции.
- Количество GTU для экземпляра.

.. _contract-instance-actions-ru:

Логирование событий
===================

.. todo::

   Explain what events are and why they are useful.
   Rephrase/clarify "monitor for events".

События могут регистрироваться во время выполнения функций смарт-контракта. Это касается
как функций инициализации, так и принимающих функций. Журналы предназначены для использования
вне сети, чтобы участники за пределами сети могли отслеживать события и реагировать на них.
Журналы недоступны для смарт-контрактов или любого другого участника в сети. События могут
регистрироваться с помощью функции, предоставляемой средой.

.. seealso::

   See :ref:`host-functions-log` for the reference of this function.

Эти журналы событий сохраняются бейкерами и включаются в сводки транзакций.

Регистрация события связана с расходами, аналогичными затратам на запись состояния контракта.
В большинстве случаев для снижения затрат имеет смысл записать в журнал только несколько байтов.

.. _action-descriptions-ru:

Описание действий
=================

Принимающая функция возвращает *описание действий*, которые должны выполняться средой в сети.

Возможные действия, которые может произвести контракт:

- **Принятие** примитивное действие, которое всегда выполняется успешно.
- **Простой перенос** GTU с экземпляра на указанный аккаунт.
- **Отправка**: вызов принимающей функции указанного экземпляра смарт-контракта и, при желании,
  передача некоторых GTU из экземпляра-отправителя в экземпляр-получатель.

Если действие не выполняется, принимающия функция отменяется, оставляя состояние и баланс
экземпляра без изменений. Однако,

- транзакция, которая запускает (неудачную) функцию получения, все еще добавляется в цепочку, и
- стоимость транзакции, включая стоимость выполнения неудавшегося действия, вычитается
  из учетной записи отправителя.

Обработка нескольких действий
-----------------------------

Вы можете описать несколько действий сети с использованием **and** комбинатора.
Описание действия ``A`` **and** ``B``

1) Выполняется ``A``.
2) В случае успеха ``A``, выполняется ``B``.
3) В случае неудачи ``B`` вся последовательность действий отклоняется (и результат ``A`` отменяется).

Обработка ошибок
----------------

Можно использовать комбинатор **or** для выполнения действия, если предыдущее действие не выполнилось.
Описание действия ``A`` **or** ``B``

1) Выполняется ``A``.
2) В случае успеха ``A``, прекращает выполнение.
3) В случае неудачи ``A``, выполняется ``B``.

.. graphviz::
   :align: center
   :caption: Example of an action description, which tries to transfer to Alice
             and then Bob, if any of these fails, it will try to transfer to
             Charlie instead.

   digraph G {
       node [color=transparent]
       or1 [label = "Or"];
       and1 [label = "And"];
       transA [label = "Transfer x to Alice"];
       transB [label = "Transfer y to Bob"];
       transC [label = "Transfer z to Charlie"];

       or1 -> and1;
       and1 -> transA;
       and1 -> transB;
       or1 -> transC;
   }

.. seealso::

   See :ref:`host-functions-actions` for a reference of how to create the
   actions.

Все дерево действий выполняется **атомарно**, и либо приводит к обновлению всех соответствующих
экземпляров и учетных записей, либо, в случае отклонения выполнения, производится оплата за выполнение,
но без других изменений. Учетная запись, отправившая инициирующую транзакцию, оплачивает
выполнение всего дерева действий.
