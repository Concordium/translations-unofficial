.. Should answer:
..
.. - Why should I use a schema?
.. - What is a schema?
.. - Where to use a schema?
.. - How is a schema embedded?
.. - Should I embed or write to file?
..

.. _`custom section`: https://webassembly.github.io/spec/core/appendix/custom.html
.. _`implementation in Rust`: https://github.com/Concordium/concordium-contracts-common/blob/main/src/schema.rs

.. _contract-schema-ru:

======================
Схемы смарт-контрактов
======================

Схема смарт-контракта - это описание того, как должны быть представлены байты
в более структурированном представлении. Эту схему могут использовать внешние
инструменты при отображении состояния экземпляра смарт-контракта и для указания
параметров с использованием структурированного представления, такого как JSON.

.. seealso::

   For instructions on how to build the schema for a smart contract module in
   Rust, see :ref:`build-schema-ru`.

Зачем использовать схему контракта?
===================================

Данные в блокчейне, такие как состояние экземпляра и параметры, передаваемые
функциям инициализации и принимающим функциям, сериализуются в виде
последовательности байтов. Сериализация оптимизирована для повышения
эффективности, а не предназначена для удобства чтения человеком.

.. todo::

   Consider rewriting this subsection as it can be somewhat difficult to
   understand; in particular, possibly just say that for convenience, the user
   can pass unserialized data into a function as long as they also provide a
   schema that spells out how to (de)serialize the data.

Обычно эти байты имеют структуру, и эта структура известна смарт-контракту
как часть функций контракта. Но за пределами этих функций может быть трудно
разобраться в байтах. Это особенно актуально при проверке сложного состояния
экземпляра контракта или при передаче сложных параметров функции смарт-контракта.
В последнем случае байты должны быть либо сериализованы из структурированных
данных, либо записаны вручную.

Существует решение, позволяющее избежать ручного анализа байтов. Оно состоит в том,
чтобы зафиксировать эту информацию в *схеме смарт-контракта*, которая описывает,
как создавать структуру из байтов, и может использоваться внешними инструментами.

.. note::

   Инструмент ``concordium-client`` может использовать схему для
   :ref:`serialize JSON parameters<init-passing-parameter-json>`
   и десериализация состояния экземпляров контракта на JSON.

Затем схема либо встраивается в модуль смарт-контракта, который развертывается
в сети, либо записывается в файл и передается вне сети.

Стоит ли встраивать или записывать в файл?
==========================================

Встраивать или записывать в файл схему контракта, зависит от вашей ситуации.

Встраивание схемы в модуль смарт-контракта позволяет распространять схему вместе
с контрактом, обеспечивая использование правильной схемы, а также позволяет
кому-либо использовать ее напрямую. Другой стороной является то, что модуль
смарт-контракта становится больше по размеру и, следовательно, дороже в
развертывании. Но если смарт-контракт не использует очень сложные типы
для состояния и параметров, размер схемы, скорее всего, будет незначительным
по сравнению с размером самого смарт-контракта.

Наличие схемы в отдельном файле позволяет вам иметь схему без оплаты
дополнительных байтов при развертывании. Другой стороной является то,
что вместо этого вам нужно распространить файл схемы через какой-то другой
канал и убедиться, что пользователи контракта используют правильный файл
с вашим смарт-контрактом.

Формат схемы
============

.. todo::

   Clarify whether we talk about *any* abstract schema that a user could implement,
   or a specific schema supplied by Concordium. Then only talk about one or the other,
   or at least clearly separate the discussion of those.

Схема может содержать

- информация о структуре для модуля смарт-контракта
- описание состояния смарт-контракта
- параметры для функции инициализации и принимающей функции смарт-контракта

Каждое из этих описаний называется *тип схемы*. Типы схемы необязательно
включать в схему.

В настоящее время поддерживаемые типы схем основаны на том, что обычно
используется в языке программирования Rust:

.. code-block:: rust

   enum Type {
       Unit,
       Bool,
       U8,
       U16,
       U32,
       U64,
       I8,
       I16,
       I32,
       I64,
       Amount,
       AccountAddress,
       ContractAddress,
       Timestamp,
       Duration,
       Pair(Type, Type),
       List(SizeLength, Type),
       Set(SizeLength, Type),
       Map(SizeLength, Type, Type),
       Array(u32, Type),
       Struct(Fields),
       Enum(List (String, Fields)),
   }

   enum Fields {
       Named(List (String, Type)),
       Unnamed(List Type),
       Empty,
   }


Здесь , ``SizeLength`` описывает количество байтов, используемых для описания
типа переменной длины, например ``List``.

.. code-block:: rust

   enum SizeLength {
       One,
       Two,
       Four,
       Eight,
   }

Для информации о том, как тип схемы сериализуется в байты, вы можете ознакомиться
в `implementation in Rust`_.

.. _contract-schema-which-to-choose-ru:

Встраивание схем в сеть
=======================

Схемы встраиваются в модули смарт-контрактов с использованием функции `custom section`_
модулей Wasm. Это позволяет модулям Wasm включать именованный раздел байтов,
что не влияет на семантику запуска модуля Wasm.

Все схемы собираются и добавляются в один настраиваемый раздел с именем
``concordium-schema-v1``.
Эта коллекция представляет собой список пар, содержащий имя контракта в кодировке
UTF-8 и байты схемы контракта.
