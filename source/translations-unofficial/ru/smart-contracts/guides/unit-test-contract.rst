.. _unit-test-contract:

=======================================
Модульное тестирование контракта в Rust
=======================================

Это руководство покажет вам, как писать модульные тесты для смарт-контракта,
написанного на Rust.
Для тестирования модуля Wasm смарт-контракта см. :ref:`local-simulate`.

Смарт-контракт в Rust написан как библиотека, и мы можем модульно тестировать
его как библиотеку, аннотируя функции атрибутом ``#[test]``.

.. code-block:: rust

    // contract code
    ...

    #[cfg(test)]
    mod test {

        #[test]
        fn some_test() { ... }

        #[test]
        fn another_test() { ... }
    }

Запуск теста можно выполнить с помощью ``cargo``:

.. code-block:: console

   $cargo test

По умолчанию эта команда компилирует контракт и тесты в машинный код для
вашего локального целевого объекта (скорее всего, ``x86_64``) и запускает их.
Этот вид тестирования может быть полезен в начальной разработке и для проверки
функциональной корректности.
Для комплексного тестирования важно задействовать целевую платформу, то есть
`Wasm32`.
Существует ряд тонких различий между платформами, которые могут изменить
поведение контракта.
Одно из отличий касается размера указателей, где ``Wasm32`` использует четыре байта,
а не восемь, что является общим для большинства платформ.

Написание модульных тестов
==========================

Модульные тесты обычно имеют трехчастную структуру, в которой вы: устанавливаете
некоторое состояние, запускаете некоторую единицу кода и делаете утверждения
о состоянии и выводе кода.

Если функции контрактов написаны с использованием ``#[init(..)]`` или
``#[receive(..)]``, мы можем протестировать эти функции непосредственно в модульном тесте.

.. code-block:: rust

   use concordium_std::*;

   #[init(contract = "my_contract", payable, enable_logger)]
   fn contract_init(
      ctx: &impl HasInitContext<()>,
      amount: Amount,
      logger: &mut impl HasLogger,
   ) -> InitResult<State> { ... }

   #[receive(contract = "my_contract", name = "my_receive", payable, enable_logger)]
   fn contract_receive<A: HasActions>(
      ctx: &impl HasReceiveContext<()>,
      amount: Amount,
      logger: &mut impl HasLogger,
      state: &mut State,
   ) -> ReceiveResult<A> { ... }

Тестовые заглушки для аргументов функции можно найти в саб-модуле
``concordium-std`` под названием ``test_infrastructure``.

.. seealso::

   For more information and examples see the crate documentation of
   concordium-std.

.. todo::

   Show more of how to write the unit test

Запуск тестов в Wasm
=====================

Компиляция тестов в собственный машинный код достаточна для большинства случаев,
но также можно скомпилировать тесты в Wasm и запустить их с помощью
точного интерпретатора, используемого узлами.
Это делает тестовую среду ближе к среде запуска по цепочке и в некоторых случаях
может отловить больше ошибок.

Инструмент разработки ``cargo-concordium`` включает в себя тестовый раннер для Wasm,
который использует тот же Wasm-интерпретатор, что и поставляемый в узлах Concordium.

.. seealso::

   For a guide of how to install ``cargo-concordium``, see :ref:`setup-tools`.

Модульный тест должен быть аннотирован с ``#[concordium_test]`` вместо
``#[test]``, и мы используем ``#[concordium_cfg_test]`` вместо ``#[cfg(test)]``:

.. code-block:: rust

   // contract code
   ...

   #[concordium_cfg_test]
   mod test {

       #[concordium_test]
       fn some_test() { ... }

       #[concordium_test]
       fn another_test() { ... }
   }

Макрос ``#[concordium_test]`` настраивает наши тесты для запуска в Wasm, когда
``concordium-std`` скомпилирован с функцией ``wasm-test``, и в противном случае
возвращается к поведению как ``#[test]``, что означает, что все еще можно запустить
модульные тесты, нацеленные на нативный код, используя ``cargo test``.

Аналогично макрос ``#[concordium_cfg_test]`` включает наш модуль при сборке
``concordium-std`` с ``wasm-test`` в противном случае ведет себя как ``#[test]``,
позволяя нам контролировать, когда включать тесты в сборку.

Теперь тесты можно создавать и запускать, используя:

.. code-block:: console

   $cargo concordium test

Эта команда компилирует тесты для Wasm с включенной функцией ``wasm-test``
для ``concordium-std`` и использует средство запуска тестов из ``cargo-concordium``.

.. Предупреждение::

   Сообщения об ошибках от ``panic!``, а, следовательно, и различные варианты
   ``assert!``, *не* отображаются при компиляции в Wasm.

   Вместо этого используйте ``fail!`` и ``claim!`` варианты выполнения утверждений
   при тестировании, так как они возвращают сообщения об ошибках исполнителю теста *перед*
   провалом теста.
   Они оба являются частью ``concordium-std``.

.. todo::

   Use link concordium-std: docs.rs/concordium-std when crate is published.
