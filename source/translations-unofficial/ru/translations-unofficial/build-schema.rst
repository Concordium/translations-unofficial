.. _list of types implementing the SchemaType: https://docs.rs/concordium-contracts-common/latest/concordium_contracts_common/schema/trait.SchemaType.html#foreign-impls


=======================
Сборка схемы контракта
=======================

Это руководство покажет, как собрать схему смарт-контракта, как экспортировать её в файл, или как встроить схему в модуль смарт-контракта, используя
``cargo-concordium``.

Подготовка
===========

Для начала убедитесь, что ``cargo-concordium`` установлен, и в случае, если он не установлен, прочтите руководство
:ref:`setup-tools` .

Нам также потребуется исходный код смарт-контракта в Rust, для которого нужно собрать схему.

Настройка контракта для использования схемы
============================================

Для того, чтобы собрать схему контракта, нам для начала нужно подготовить наш смарт-контракт для сборки схемы.

Мы можем выбрать, какая часть нашего смарт-контракта будет включена в схему. Возможны следующие варианты: включение схемы для состояния контракта, и/или для каждого параметра init-функции и функции приёма.

Каждый тип, который мы хотим включить в схему, должен реализовать трейт ``SchemaType``.Реализация этого трейта уже существует для всех базовых типов и некоторых других типов (смотрите `list of types implementing the SchemaType`_).
В большинстве других случаев, этого можно добиться автоматически, используя макрос
``#[derive(SchemaType)]``::

   #[derive(SchemaType)]
   struct SomeType {
       ...
   }

Реализация трейта ``SchemaType`` вручную требует определения только одной функции, являющейся геттер-методом для ``schema::Type``, который по сути описывает, как этот тип отображается в байтах и как отображать его.
how this type is represented as bytes and how to represent it.

.. todo::

   Создайте пример, демонстрирующий ручную реализацию ``SchemaType``, и прикрепите
   ссылку на него здесь.

Включение состояния контракта
--------------------------------

Чтобы сгенерировать и включить схему для состояния контракта, мы аннотируем тип макросом ``#[contract_state(contract = ...)]`` ::

   #[contract_state(contract = "my_contract")]
   #[derive(SchemaType)]
   struct MyState {
       ...
   }

Или ещё проще, если состояние контракта имеет тип, который уже реализует ``SchemaType``, например, u32::

   #[contract_state(contract = "my_contract")]
   type State = u32;

Включение параметров функции
-----------------------------

Чтобы сгенерировать и включить схему для параметров init-функции и функции приёма, мы зададим дополнительный атрибут ``parameter`` для макросов
``#[init(..)]``- и ``#[receive(..)]`` ::

   #[derive(SchemaType)]
   enum InitParameter { ... }

   #[derive(SchemaType)]
   enum ReceiveParameter { ... }

   #[init(contract = "my_contract", parameter = "InitParameter")]
   fn contract_init<...> (...){ ... }

   #[receive(contract = "my_contract", name = "my_receive", parameter = "ReceiveParameter")]
   fn contract_receive<...> (...){ ... }

Сборка схемы
===================

Теперь мы готовы, собрать актуальную схему, используя ``cargo-concordium``, и имея выбор: встроить схему или записать схему в файл, или оба варианта.

.. seealso::

   Более подробно о способах хранения схем смотрите
   здесь
   :ref:`here<contract-schema-which-to-choose>`.

Встраивание схемы
--------------------

Для того, чтобы встроить схему в модуль смарт-контракта, мы добавляем аргумент
``--schema-embed`` в команду сборки

.. code-block:: console

   $cargo concordium build --schema-embed

В случае успеха результат выполнения команды отобразит общий размер схемы в байтах.

Вывод схемы в файл
------------------------

Для вывода схемы в файл мы можем использовать ``--schema-out=FILE``
где ``FILE`` - путь к создаваемому файлу:

.. code-block:: console

   $cargo concordium build --schema-out="/some/path/schema.bin"
