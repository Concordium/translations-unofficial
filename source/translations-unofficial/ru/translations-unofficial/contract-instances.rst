============================
Экземпляры смарт-контракта
============================

.. todo::

   - Выясните, как экземпляры соотносятся со смарт-контрактами и с модулями
     (например, прямо сейчас говорится, что экземпляр - это модуль + состояние, но
     изображение ниже показывает, что экземпляр - это контракты + состояние).
   - Определите, как дать более точное определение модулям смарт-контракта (как
     самостоятельное понятие или как модули в семантике Wasm), и стоит ли нам
     говорить о них вообще.
   - Определите, нужен ли нам код конкретного примера, и должен ли он быть
     написан  в Wasm, в Rust, или возможно в псевдокоде.
   - Обсудите изображение, на котором объясняется взаимосвязь между модулями и
     экземплярами.

**Экземпляр смарт-контракта** это модуль смарт-контракта вместе с определённым состоянием и количеством GTU-токенов. Множественные экземпляры смарт-контракта могут быть созданы из одного и того же модуля.
Например, для контракта :ref:`auction <auction>` может существовать множество экземпляров, каждый из которых предназначен для проведения торгов по определённому товару, каждый со своими участниками.

Экземпляры смарт-контрактов могут быть созданы из развёрнутого :ref:`smart contract
module<contract-module>` посредством ``init`` транзакции,которая обращается к запрашиваемой функции в модуле смарт-контракта. Эта функция может принимать какой-нибудь параметр. Её конечным результатом должно быть начальное состояние экземпляра смарт-контракта.

.. note::

   Экземпляр смарт-контракта зачастую просто называют *экземпляром*.

.. graphviz::
   :align: center
   :caption: Пример модуля, который содержит два смарт-контракта:
             Escrow and Crowdfunding. Каждый контракт имеет два экземпляра.

   digraph G {
       rankdir="BT"

       subgraph cluster_0 {
           label = "Module";
           labelloc=b;
           node [fillcolor=white, shape=note]
           "Crowdfunding";
           "Escrow";
       }

       subgraph cluster_1 {
           label = "Instances";
           style=dotted;
           node [shape=box, style=rounded]
           House;
           Car;
           Gadget;
           Boardgame;
       }

       House:n -> Escrow;
       Car:n -> Escrow;
       Gadget:n -> Crowdfunding;
       Boardgame:n -> Crowdfunding;
   }

Состояние экземпляра смарт-контракта
=====================================

Состояние экземпляра смарт-контракта состоит из двух частей: определённого пользователем состояния и количества GTU, удерживаемых контрактом, то есть его *баланс*.
Когда мы говорим о состоянии, то обычно подразумеваем только определённое пользователем состояние. Причина для обработки количества GTU отдельно заключается в том, что GTU могут быть только потрачены и получены согласно правилам сети, например, контракты не могут создавать или уничтожать GTU-токены.

.. _contract-instances-init-on-chain:

Создание on-chain экземпляра смарт-контракта
=============================================

Каждый смарт-контракт должен содержать функцию создания экземпляра смарт-контракта. Такая функция называется *init function*.

Для создания экземпляра смарт-контракта аккаунт посылает особую транзакцию, содержащую ссылку на развёрнутый модуль смарт-контракта и имя init-функции, используемой для создания экземпляра.

Транзакция также может включать количество GTU, зачисляемых на баланс экземпляра смарт-контракта. Параметр функции передаётся как часть транзакции в виде массива байтов.

Если вкратце, транзакция включает в себя:

- Ссылку на модуль смарт-контракта.
- Имя init-функции.
- Параметры для init-функции.
- Количество GTU для экземпляра.

init-функция может послать сигнал, означающий, что она не хочет создавать новый экземпляр с заданными параметрами. Если init-функция принимает параметры, она задаёт начальное состояние экземпляра и его баланс. Экземпляру присваивается адрес в цепочке и аккаунт, отправивший транзакцию, становится владельцем экземпляра. Если функция отклоняет запрос, экземпляр не создаётся, и тогда в цепочке видна только транзакция для попытки создать экземпляр.

.. seealso::

   Смотрите :ref:`initialize-contract` для понимания инициализации контракта на практике.

Состояние экземпляра
=====================

Каждый экземпляр смарт-контракта содержит значение своего состояния, представленного в цепочке как массив байтов. Экземпляр использует функции, поддерживаемые средой хоста, для чтения, записи и изменения состояния.

.. seealso::

   Смотрите :ref:`host-functions-state` для справки по этим функциям.

Состояние смарт-контракта имеет ограничения по размеру. На данный момент ограничение размера состояния смарт-контракта составляет 16 Кбайт.

.. seealso::

   Смотрите :ref:`resource-accounting` для получения более подробной информации.

Взаимодействие с экземпляром
============================

Смарт-контракт может предоставлять ноль или более функций для взаимодействия с экземпляром, называемых *функциями приёма*.

Точно также, как и в случае с init-функциями, функции приёма вызываются посредством отправки транзакций, которые содержат некоторое количество GTU для контракта и аргумент функции в виде байтов.

Если вкратце, транзакция для взаимодействия со смарт-контрактом включает в себя:

- Адрес экземпляра смарт-контракта.
- Имя функции приёма.
- Параметры функции приёма.
- Количество GTU для экземпляра.

.. _contract-instance-actions:

Запись журнала событий
=======================

.. todo::

   Поясните, что такое события и чем они полезны.
   Перефразируйте и уточните, что означает "monitor for events".

События могут быть зарегистрированы в процессе выполнения функций смарт-контракта. Это справедливо как для init-функции, так и для функции приёма. Журналы предназначены для off-chain использования, благодаря чему участники вне цепочки могут отслеживать события и реагировать на них. Журналы не доступны смарт-контрактам или любым другим участникам в цепочке. События не могут фиксироваться при помощи функций среды хоста.

.. seealso::

   Смотрите :ref:`host-functions-log` для получения справки по этим функциям.

Эти журналы событий сохраняются baker-ами и включаются в отчёты транзакций.
Журналирование событий имеет соответствующую стоимость, подобную стоимости записи в состояние контракта. В большинстве случаев может иметь смысл запись только нескольких байтов для снижения стоимости.

.. _action-descriptions:

Описания действий
===================

Функция приёма возвращает *описание действий* которые будут выполнены средой хоста в цепочке.

Возможные действия, генерируемые контрактом:

- **Принять** - примитивное действие, которое всегда завершается успехом.
- **Простая передача** of GTU от экземпляра определённому аккаунту.
- **Отправить**: вызывает функцию приёма определённого экземпляра смарт-контракта, а также дополнительно пересылает определённое количество GTU от отправляющего экземпляра принимающему.

Если действие терпит неудачу при выполнении, функция приёма откатывается, оставляя состояние и баланс экземпляра неизменным. Тем не менее,

- транзакция, которая запускает (неуспешно выполненную) функцию приёма остаётся в цепочке,
- стоимость транзакции, включая стоимость выполненного неуспешного действия, вычитается у отправляющего аккаунта.

Обработка описаний составных действий
---------------------------------------

Описания действий можно соединить в цепочку, используя комбинатор **and**.
Последовательность описаний действий ``A`` **and** ``B``

1) Выполняется ``A``.
2) Если ``A`` успешно, выполняется ``B``.
3) Если ``B`` терпит неудачу, вся последовательность действий терпит неудачу (и результат ``A`` откатывается).

Обработка ошибок
-----------------

Используйте комбинатор **or** для выполнения действия в случае, если предыдущее действие терпит неудачу. Описание действия ``A`` **or** ``B``

1) Выполняется ``A``.
2) Если ``A`` успешно, выполнение прекращается.
3) Если ``A`` терпит неудачу, выполняется ``B``.

.. graphviz::
   :align: center
   :caption: Example of an action description, which tries to transfer to Alice
             and then Bob, if any of these fails, it will try to transfer to
             Charlie instead.

   digraph G {
       node [color=transparent]
       or1 [label = "Or"];
       and1 [label = "And"];
       transA [label = "Transfer x to Alice"];
       transB [label = "Transfer y to Bob"];
       transC [label = "Transfer z to Charlie"];

       or1 -> and1;
       and1 -> transA;
       and1 -> transB;
       or1 -> transC;
   }

.. seealso::

   Смотрите :ref:`host-functions-actions` для получения справки о создании
   действий.

Всё дерево действий выполняется **атомарно**,  и, либо приводит к обновлению всех задействованных экземпляров и аккаунтов, либо, в случае отказа, к оплате за выполнение, но не к другим действиям. Аккаунт, который отправляет инициирующую транзакцию, оплачивает выполнение всего дерева.
