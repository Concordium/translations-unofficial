.. Should answer:
..
.. - Why should I use a schema?
.. - What is a schema?
.. - Where to use a schema?
.. - How is a schema embedded?
.. - Should I embed or write to file?
..

.. _`custom section`: https://webassembly.github.io/spec/core/appendix/custom.html
.. _`implementation in Rust`: https://github.com/Concordium/concordium-contracts-common/blob/main/src/schema.rs

======================
Схемы смарт-контрактов
======================

Схемы смарт-контрактов – это описание того, как представить последовательности байтов в более структурированной форме. Они могут использоваться внешними инструментами для отображения состояния экземпляра смарт-контракта и для определения параметров с помощью структурированного представления, такого как JSON.

.. seealso::

   Для получения инструкций по сборке схемы для модуля смарт-контракта в
   Rust, смотрите :ref:`build-schema`.

Зачем нужна схема контракта
============================

Данные о блокчейн, такие как состояние экземпляра и параметры, передаваемые в init-функцию и функцию приёма, сериализуются в последовательность байтов. Сериализация оптимизирована для эффективности, но не для удобства чтения человеком.

.. todo::

   Подумайте над тем, как переписать этот подраздел, так как он может быть достаточно
   сложен для восприятия; в частности, можно просто сказать, что для удобства
   пользователь может передать сериализованные данные в функцию при условии, что она
   поддерживает схему, которая понимает, как сериализовать и десериализовать данные.

Как правило, эти байты структурированы и эта структура известна смарт-контракту как часть функций контракта, но вне этих функций может быть достаточно трудно разобраться в этих байтах. Особенно при исследовании сложного состояния экземпляра контракта или при передаче сложных параметров в функцию смарт-контракта. В последнем случае байты должны быть либо сериализованы из структурированных данных, либо записаны вручную.

Решением для исключения необходимости синтаксического анализа байтов вручную является захват этой информации в
*схему смарт-контракта*, которая описывает, как создать структуру из байтов и как эта структура может использоваться внешними инструментами.

.. note::

   Утилита ``concordium-client`` может использовать схему для
   :ref:`serialize JSON parameters<init-passing-parameter-json>`
   и для десериализации состояния экземпляра контракта в JSON.

Затем схема либо встраивается в модуль смарт-контракта, развёрнутого в цепочке, либо записывается в файл и передаётся в off-chain.

Встраивать в модуль или записывать в файл?
===========================================

Выбор между встраиванием схемы контракта в модуль и записью в файл зависит от ситуации.

Встроенная в модуль смарт-контракта схема раздаётся вместе с контрактом, гарантируя использование корректной схемы, а также позволяет всем использовать её напрямую. Недостаток заключается в том, что модуль смарт-контракта становится больше по размеру и, следовательно, более затратным при развёртывании. Но до тех пор, пока смарт-контракт не использует слишком сложные типы данных для описания состояния и параметров, размер схемы будет скорее всего незначительным по сравнению с размером самого контракта.

Хранение схемы в отдельном файле позволяет пользоваться схемой без оплаты за дополнительные байты при развёртывании. Недостатком в этом случае является то, что придётся раздавать файл схемы по каким-то другим каналам и контролировать, чтобы пользователи контракта использовали правильный файл при работе с этим смарт-контрактом.

Формат схемы
=================

.. todo::

   Поясните, говорим ли мы о *какой-то* абстрактной схеме, которую может реализовать
   пользователь, или об определённой схеме, поддерживаемой Concordium. Затем обсудите
   ту или другую, или по крайне мере чётко разделите их обсуждение.

Схема может содержать

- структурированную информацию для модуля смарт-контракта
- описание состояния смарт-контракта
- параметры для init-функции и функции приёма смарт-контракта.

Каждое из этих описаний называют *типом схемы*. Тип схемы всегда опционально включается в схему.

На данный момент поддерживаемые типы схем сформированы на основе типов, широко применяемых в языке программирования Rust:

.. code-block:: rust

   enum Type {
       Unit,
       Bool,
       U8,
       U16,
       U32,
       U64,
       I8,
       I16,
       I32,
       I64,
       Amount,
       AccountAddress,
       ContractAddress,
       Timestamp,
       Duration,
       Pair(Type, Type),
       List(SizeLength, Type),
       Set(SizeLength, Type),
       Map(SizeLength, Type, Type),
       Array(u32, Type),
       Struct(Fields),
       Enum(List (String, Fields)),
   }

   enum Fields {
       Named(List (String, Type)),
       Unnamed(List Type),
       Empty,
   }


Параметр, ``SizeLength`` описывает количество байтов, используемых для описания размера типа переменной длины, такого как ``List``.

.. code-block:: rust

   enum SizeLength {
       One,
       Two,
       Four,
       Eight,
   }

Для получения справки о том, как типы схемы сериализуются в байты, мы отсылаем читателя к `implementation in Rust`_.

.. _contract-schema-which-to-choose:

Встраивание on-chain схем
==========================

Схемы встраиваются в модули смарт-контрактов, используя свойство `custom
section`_ модулей Wasm.
Это позволяет модулям Wasm включать именованные секции байтов, которые не затрагивают семантику запуска модулей Wasm.

Все схемы собираются и добавляются в одну кастомную секцию с именем
``concordium-schema-v1``.
Эта коллекция представляет собой список пар, состоящих из имени контракта в кодировке UTF-8 и байтов схемы контракта.
