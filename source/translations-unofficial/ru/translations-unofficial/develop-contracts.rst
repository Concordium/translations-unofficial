.. Should answer:
    - Why write a smart contract using rust?
    - What are the pieces needed to write a smart contract in rust?
        - State
            - Serialized
            - Schema
        - Init
        - Receive
    - What sort of testing is possible
    - Best practices?
        - Ensure 0 amount
        - Don't panic
        - Avoid heavy calculations

=====================================
Разработка смарт-контрактов в  Rust
=====================================

В блокчейн Concordium смарт-контракты развёртываются как Wasm-модули, однако Wasm изначально спроектирован как цель компиляции и непригоден для ручного кодирования. Вместо этого мы можем написать наши смарт-контракты на языке программирования
Rust_ который имеет хорошую поддержку компиляции в Wasm.

Смарт-контракты необязательно писать в Rust. Это просто первый SDK, который мы представили. Вручную написанный Wasm-код, или Wasm-код, скомпилированный из C, C++, AssemblyScript_, and
и так далее, равно допустим в цепочке при условии, что он строго придерживается :ref:`установленных ограничений Wasm <wasm-limitations>`.

.. seealso::

   Для получения более подробной информации по функциям, описанным ниже, смотрите concordium_std_
   API для написания смарт-контрактов для блокчейна Concordium в Rust.

.. seealso::

   Смотрите :ref:`contract-module` для получения более подробной информации о
   модулях смарт-контрактов.Модуль смарт-контракта разрабатывается в Rust как библиотечный контейнер (crate), который затем компилируется в Wasm-код. Чтобы обеспечить правильный экспорт, атрибут crate-type должен быть установлен в значение ``["cdylib", "rlib"]`` в файле манифеста:

.. code-block:: text

   ...
   [lib]
   crate-type = ["cdylib", "rlib"]
   ...

Написание смарт-контракта с использованием ``concordium_std``
==============================================================

Рекомендуется использовать контейнер ``concordium_std`` который обеспечивает Rust-подобный интерфейс для разработки модулей смарт-контрактов и вызова функций хоста.

Контейнер позволяет написать init-функцию и функцию приёма как обычные функции Rust в следующей аннотации ``#[init(...)]`` and ``#[receive(...)]``, соответственно.

Ниже приведён пример смарт-контракта, реализующего счётчик:

.. code-block:: rust

   use concordium_std::*;

   type State = u32;

   #[init(contract = "counter")]
   fn counter_init(
       _ctx: &impl HasInitContext,
   ) -> InitResult<State> {
       let state = 0;
       Ok(state)
   }

   #[receive(contract = "counter", name = "increment")]
   fn contract_receive<A: HasActions>(
       ctx: &impl HasReceiveContext,
       state: &mut State,
   ) -> ReceiveResult<A> {
       ensure!(ctx.sender().matches_account(&ctx.owner()); // Only the owner can increment
       *state += 1;
       Ok(A::accept())
   }

Следует отметить несколько моментов:

.. todo::

   - Составьте требования в более лёгкой для чтения форме (например, разделите пункты
     на подпункты).
   - Эти требования должны быть частью спецификации, которая где-то описана, то есть
     не просто как часть этого примера.

- Типы функций:
  * init-функция должна быть типа ``&impl HasInitContext -> InitResult<MyState>`` где ``MyState`` тип, который реализует трейт Serialize.
  * Функция приёма должна принимать параметр типа ``A: HasActions`` , ``&impl HasReceiveContext`` и параметр ``&mut MyState`` , и возвращать ``ReceiveResult<A>``.

- Аннотация ``#[init(contract = "counter")]`` помечает функцию, к которой она применяется, как init-функцию контракта с именем ``counter``.
  Конкретно это означает, что за кадром этот макрос генерирует экспортируемую функцию с требуемой сигнатурой и именем``init_counter``.

- ``#[receive(contract = "counter", name = "increment")]`` десериализует и предоставляет состояние, которым можно манипулировать напрямую. За кадром эта аннотация также генерирует экспортируемую функцию с именем
  ``counter.increment`` которая имеет требуемую сигнатуру и выполняет все шаблоны десериализации состояния в требуемый тип ``State``.

.. note::

   Заметим, что десериализация не имеет нулевой стоимости, и в некоторых случаях пользователь хочет иметь более точечный контроль над использованием функций хоста. Для таких случаев аннотация поддерживают опцию ``low_level`` которая создаёт меньше расходов, но требует большего участия пользователя.

.. todo::

   - Объясните, что значит  low-level
   - Представьте концепцию функций хоста до их использования в узле, приведённом выше


Сериализуемые состояния и параметры
------------------------------------

.. todo:: Поясните, что означает, что состояние отображается аналогично``File``;
   желательно не ссылаясь на ``File``.

Состояние on-chain экземпляра представляет собой массив байтов и отображается в интерфейс, аналогичный интерфейсу
``File`` стандартной библиотеки Rust.

Это может быть выполнено при помощи трейта ``Serialize`` который содержит функции сериализации и десериализации.

Контейнер ``concordium_std`` содержит этот трейт и реализации для большинства типов стандартной библиотеки Rust. Он также содержит макросы для получения трейта для определяемых пользователем structs и
enums.

.. code-block:: rust

   use concordium_std::*;

   #[derive(Serialize)]
   struct MyState {
       ...
   }

То же самое необходимо сделать для параметров, передаваемых в init-функцию и функцию приёма.

.. note::

   Строго говоря, нам только требуется десериализовать байты в наш тип параметра, однако удобно иметь возможность сериализовать типы при написании модульных тестов.

.. _working-with-parameters:

Работа с параметрами
-----------------------

Параметры init-функции и функции приёма, как и состояние экземпляра, представлено массивом байтов. Хотя массивы байтов могут использоваться непосредственно, они также могут быть десериализованы в структурированные данные.

Наипростейший способ десериализовать параметр – использовать функцию `get()`_ трейта `Get`_ .

В качестве примера рассмотрим следующий контракт, в котором параметр
``ReceiveParameter`` десериализуется в подсвеченных строках:

.. code-block:: rust
   :emphasize-lines: 24

   use concordium_std::*;

   type State = u32;

   #[derive(Serialize)]
   struct ReceiveParameter{
       should_add: bool,
       value: u32,
   }

   #[init(contract = "parameter_example")]
   fn init(
       _ctx: &impl HasInitContext,
   ) -> InitResult<State> {
       let initial_state = 0;
       Ok(initial_state)
   }

   #[receive(contract = "parameter_example", name = "receive")]
   fn receive<A: HasActions>(
       ctx: &impl HasReceiveContext,
       state: &mut State,
   ) -> ReceiveResult<A> {
       let parameter: ReceiveParameter = ctx.parameter_cursor().get()?;
       if parameter.should_add {
           *state += parameter.value;
       }
       Ok(A::accept())
   }

Функция приёма, показанная выше, неэффективна из-за того, что она десериализует
``value`` даже когда в этом нет необходимости, то есть, когда ``should_add`` равно ``false``.

Для получения большего контроля, а в данном случае, и повышения эффективности, мы можем десериализовать параметр, используя трейт `Read`_ :

.. code-block:: rust
   :emphasize-lines: 7, 10

   #[receive(contract = "parameter_example", name = "receive_optimized")]
   fn receive_optimized<A: HasActions>(
       ctx: &impl HasReceiveContext,
       state: &mut State,
   ) -> ReceiveResult<A> {
       let mut cursor = ctx.parameter_cursor();
       let should_add: bool = cursor.read_u8()? != 0;
       if should_add {
           // Only decode the value if it is needed.
           let value: u32 = cursor.read_u32()?;
           *state += value;
       }
       Ok(A::accept())
   }

Заметим, что ``value`` десериализуется только, если ``should_add`` равно ``true``.
Хоть выигрыш в эффективности в этом примере минимален, он может сыграть существенную роль для более сложных примеров.


Сборка модуля смарт-контракта с помощью ``cargo-concordium``
=============================================================

Компилятор Rust имеет хорошую поддержку для компиляции в Wasm-код, используя цель
``wasm32-unknown-unknown``.
Однако, даже при компиляции в ``--release`` итоговая сборка содержит большие секции отладочной информации в кастомных секциях, которые не несут пользы для on-chain смарт-контрактов.


Для оптимизации сборки и для применения новых возможностей, таких как встроенные схемы, мы рекомендуем использовать утилиту ``cargo-concordium`` для сборки смарт-контрактов.

.. seealso::

   Для получения инструкций по сборке с использованием ``cargo-concordium`` смотрите :ref:`compile-module`.


Тестирование смарт-контрактов
==============================

Модульные тесты с заглушками
-----------------------------

Симуляция обращений к контракту
---------------------------------

Лучшие практики
=================

Без паники
-----------

.. todo::

   Use trap instead.

Избегайте создания чёрных дыр
-------------------------------

Смарт-контракт не требуется для использования количества GTU, отправленных ему, и по умолчанию смарт-контракт не задаёт никакого поведения для обнуления баланса экземпляра в случае, если кто-то отправит определённое количество GTU. Эти GTU были бы тогда *потеряны*, навсегда, и ничего нельзя было бы сделать для их восстановления.

Поэтому хорошая практика для смарт-контрактов сводится к тому, чтобы не иметь дела с GTU и гарантировать, что отправляемое количество GTU равно нулю, и отклонять любые обращения с ненулевым количеством GTU.

Перенос сложных вычислений в off-chain
---------------------------------------


.. _Rust: https://www.rust-lang.org/
.. _Cargo: https://doc.rust-lang.org/cargo/
.. _AssemblyScript: https://github.com/AssemblyScript
.. _get(): https://docs.rs/concordium-std/latest/concordium_std/trait.Get.html#tymethod.get
.. _Get: https://docs.rs/concordium-std/latest/concordium_std/trait.Get.html
.. _Read: https://docs.rs/concordium-std/latest/concordium_std/trait.Read.html
.. _concordium_std: https://docs.rs/concordium-std/latest/concordium_std/
