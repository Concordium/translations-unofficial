.. _unit-test-contract:

========================================
Модульное тестирование контракта в Rust
========================================

Это руководство покажет, как написать модульные тесты для смарт-контрактов, написанных в Rust. Для тестирования Wasm-модуля смарт-контракта, смотрите  :ref:`local-simulate`.

Смарт-контракт в Rust создаётся в виде библиотеки и мы можем запустить для него модульное тестирование как для библиотеки при помощи аннотирования функций атрибутом ``#[test]`` .

.. code-block:: rust

    // contract code
    ...

    #[cfg(test)]
    mod test {

        #[test]
        fn some_test() { ... }

        #[test]
        fn another_test() { ... }
    }

Запустить тест можно с помощью ``cargo``:

.. code-block:: console

   $cargo test

По умолчанию, эта команда компилирует контракт и тесты в машинный код под локальную пользовательскую платформу (чаще всего ``x86_64``), и запускает их.
Этот вид тестирования может быть полезен в начальной разработке и для тестирования функциональной корректности. Для комплексного тестирования, важно задействовать целевую платформу, то есть `Wasm32`.
Существует множество тонких различий между платформами, которые могут повлиять на поведение контракта. Одно из различий касается размера указателей. Wasm32 использует четыре байта, тогда как восьмибайтовый указатель является наиболее распространённым для большинства платформ.

Пишем модульные тесты
======================

Модульные тесты чаще всего соответствуют трёхчастной структуре, в которой: задаётся определённое состояние, запускается определённая часть кода, и делается заключение о состоянии и результате выполнения кода.

Если функции контракта написаны с применением  ``#[init(..)]`` или
``#[receive(..)]``, мы можем протестировать эти функции непосредственно в модульном тесте.

.. code-block:: rust

   use concordium_std::*;

   #[init(contract = "my_contract", payable, enable_logger)]
   fn contract_init(
      ctx: &impl HasInitContext<()>,
      amount: Amount,
      logger: &mut impl HasLogger,
   ) -> InitResult<State> { ... }

   #[receive(contract = "my_contract", name = "my_receive", payable, enable_logger)]
   fn contract_receive<A: HasActions>(
      ctx: &impl HasReceiveContext<()>,
      amount: Amount,
      logger: &mut impl HasLogger,
      state: &mut State,
   ) -> ReceiveResult<A> { ... }

Заглушки для тестирования аргументов функции можно найти в подмодуле
``concordium-std`` , который называется ``test_infrastructure``.

.. seealso::

   Для получения более подробной информации и примеров смотрите документацию по concordium-std.

.. todo::

   Покажите больше примеров написания модульных тестов

Запуск тестов в Wasm
=====================

Компилирование тестов в нативный машинный код обосновано в большинстве случаев, но также возможно компилировать тесты в Wasm-код и запускать их, используя тот же интерпретатор, который используется узлами. Это делает тестовую среду более приближенной к реальной on-chain среде и в некоторых случаях помогает ловить больше багов.

Утилита для разработки ``cargo-concordium`` включает в себя тест-раннер для Wasm, который использует тот же Wasm-интерпретатор, что и узлы Concordium.

.. seealso::

   Для получения инструкций по установке ``cargo-concordium``, смотрите :ref:`setup-tools`.

Модульный тест должен быть аннотирован с ``#[concordium_test]``  вместо
``#[test]``, а также мы используем ``#[concordium_cfg_test]``  вместо  ``#[cfg(test)]``:

.. code-block:: rust

   // contract code
   ...

   #[concordium_cfg_test]
   mod test {

       #[concordium_test]
       fn some_test() { ... }

       #[concordium_test]
       fn another_test() { ... }
   }

Макрос ``#[concordium_test]`` указывает нашим тестам запускаться в Wasm, когда
``concordium-std`` скомпилирован со свойством wasm-test, в противном случае – возвращает тесты к поведению как при ``#[test]``, а это означает, что всё равно можно запустить модульные тесты для нативного кода, используя cargo test.

Аналогично макрос ``#[concordium_cfg_test]`` включает наш модуль, при сборке
``concordium-std`` со свойством ``wasm-test`` иначе ведёт себя как при ``#[test]``,
позволяя нам решать, когда необходимо включать тесты в сборку.

Тесты теперь могут быть скомпилированы и запущены с помощью команды:

.. code-block:: console

   $cargo concordium test

Эта команда компилирует тесты для Wasm с аттрибутом ``wasm-test`` , разрешённым для ``concordium-std`` и использует тест-раннер из ``cargo-concordium``.

.. warning::

   Сообщения об ошибках от ``panic!``, и, следовательно, от различных вариаций ``assert!``, are *не* отображаются при компилировании в Wasm.

   Вместо этого используйте варианты ``fail!`` и ``claim!`` чтобы делать проверку утверждений во время тестирования, так как они отправляют отчёты об ошибке тест-раннеру *до*
   того, как тест завершится с ошибкой. Оба варианта являются частью ``concordium-std``.

.. todo::

   Используйте ссылку concordium-std: docs.rs/concordium-std при публикации
   контейнера.
