.. Should answer:
..
.. - Why should I use a schema?
.. - What is a schema?
.. - Where to use a schema?
.. - How is a schema embedded?
.. - Should I embed or write to file?
..

.. _`custom section`: https://webassembly.github.io/spec/core/appendix/custom.html
.. _`implementation in Rust`: https://github.com/Concordium/concordium-contracts-common/blob/main/src/schema.rs

.. _contract-schema:

======================
Схеми смарт-контрактів
======================

Схема смарт-контракту - це опис того, як повинні бути представлені байти в більш структурованому представленні.
Цю схему можуть використовувати зовнішні інструменти при відображенні стану екземпляра смарт-контракту і для вказівки параметрів з використанням структурованого уявлення, такого як JSON.

.. seealso::

   For instructions on how to build the schema for a smart contract module in
   Rust, see :ref:`build-schema`.

Навіщо використовувати схему контракту?
=======================================

Дані в блокчейне, такі як стан екземпляра і параметри, що передаються функцій ініціалізації і приймають функцій, серіалізуются у вигляді послідовності байтів.
Серіалізация оптимізована для підвищення ефективності, а не призначена для зручності читання людиною.

.. todo::

   Consider rewriting this subsection as it can be somewhat difficult to
   understand; in particular, possibly just say that for convenience, the user
   can pass unserialized data into a function as long as they also provide a
   schema that spells out how to (de)serialize the data.

Зазвичай ці байти мають структуру, і ця структура відома смарт-контракту як частина функцій контракту.
Але за межами цих функцій може бути важко розібратися в байтах.
Це особливо актуально при перевірці складного стану екземпляра контракту або при передачі складних параметрів функції смарт-контракту.
В останньому випадку байти повинні бути або серіалізовані з структурованих даних, або записані вручну.

Існує рішення, що дозволяє уникнути ручного аналізу байтів.
Воно полягає в тому, щоб зафіксувати цю інформацію в *схемі смарт-контракту*, яка описує, як створювати структуру з байтів, і може використовуватися зовнішніми інструментами.

.. note::
   Інструмент ``concordium-client`` може використовувати схему для :ref:`serialize JSON parameters<init-passing-parameter-json>` і десеріалізацію стану примірників контракту на JSON.

Потім схема або вбудовується в модуль смарт-контракту, який розгортається в мережі, або записується в файл і передається поза мережею.

Стоит ли встраивать или записывать в файл?
==========================================

Вбудовувати або записувати в файл схему контракту, залежить від вашої ситуації.

Вбудовування схеми в модуль смарт-контракту дозволяє поширювати схему разом з контрактом, забезпечуючи використання правильної схеми, а також дозволяє будь-кому використовувати її безпосередньо.
Іншою стороною є те, що модуль смарт-контракту стає більше за розміром і, отже, дорожче в розгортанні.
Але якщо смарт-контракт не використовує дуже складні типи для стану і параметрів, розмір схеми, швидше за все, буде незначним в порівнянні з розміром самого смарт-контракту.

Наявність схеми в окремому файлі дозволяє вам мати схему без оплати додаткових байтів при розгортанні.
Іншою стороною є те, що замість цього вам потрібно поширити файл схеми через якийсь інший канал і переконатися, що користувачі контракту використовують правильний файл з вашим смарт-контрактом.

Формат схеми
============

.. todo::

   Clarify whether we talk about *any* abstract schema that a user could implement,
   or a specific schema supplied by Concordium. Then only talk about one or the other,
   or at least clearly separate the discussion of those.

Схема може містити:

- інформація про структуру для модуля смарт-контракту
- опис стану смарт-контракту
- параметри для функції ініціалізації і приймаючої функції смарт-контракту

Кожне з цих описів називається встановлений *тип схеми*. Типи схеми необов'язково включати в схему.

В даний час підтримуються типи схем засновані на тому, що зазвичай використовується в мові програмування Rust:

.. code-block:: rust

   enum Type {
       Unit,
       Bool,
       U8,
       U16,
       U32,
       U64,
       I8,
       I16,
       I32,
       I64,
       Amount,
       AccountAddress,
       ContractAddress,
       Timestamp,
       Duration,
       Pair(Type, Type),
       List(SizeLength, Type),
       Set(SizeLength, Type),
       Map(SizeLength, Type, Type),
       Array(u32, Type),
       Struct(Fields),
       Enum(List (String, Fields)),
   }

   enum Fields {
       Named(List (String, Type)),
       Unnamed(List Type),
       Empty,
   }

Тут, ``SizeLength`` описує кількість байтів, використовуваних для опису типу змінної довжини, наприклад ``List``.

.. code-block:: rust

   enum SizeLength {
       One,
       Two,
       Four,
       Eight,
   }

Для інформації про те, як встановлений режим роботи серіалізуются в байти, ви можете ознайомитися в `implementation in Rust`_.

.. _contract-schema-which-to-choose:

Вбудовування схем в мережу
==========================

Схеми вбудовуються в модулі смарт-контрактів з використанням функції `custom section`_ модулів Wasm.
Це дозволяє модулям Wasm включати іменований розділ байтів, що не впливає на семантику запуску модуля Wasm.

Всі схеми збираються і додаються в один настроюється розділ з ім'ям ``concordium-schema-v1``.
Ця колекція представляє собою список пар, що містить ім'я контракту в кодуванні UTF-8 і байти схеми контракту.
