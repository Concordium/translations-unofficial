.. _unit-test-contract:

====================================
Модульне тестування контракту в Rust
====================================

Це керівництво покаже вам, як писати модульні тести для смарт-контракту, написаного на Rust.
Для тестування модуля Wasm смарт-контракту дивіться :ref:`local-simulate`.

Смарт-контракт в Rust написаний як бібліотека, і ми можемо модульно тестувати його як бібліотеку, анотуючи функції атрибутом ``#[test]``.

.. code-block:: rust

    // contract code
    ...

    #[cfg(test)]
    mod test {

        #[test]
        fn some_test() { ... }

        #[test]
        fn another_test() { ... }
    }

Запуск тесту можна виконати за допомогою ``cargo``:

.. code-block:: console

   $cargo test

За замовчуванням ця команда компілює контракт і тести в машинний код для вашого локального цільового об'єкта (швидше за все ``x86_64``) і запускає їх.
Цей вид тестування може бути корисний в початковій розробці і для перевірки функціональної коректності.
Для комплексного тестування важливо задіяти цільову платформу, тобто `Wasm32`.
Існує ряд тонких відмінностей між платформами, які можуть змінити поведінку контракту.
Одна з відмінностей стосується розміру покажчиків, де `Wasm32` використовує чотири байти, а не вісім, що є загальним для більшості платформ.

Написання модульних тестів
==========================

Модульні тести зазвичай мають трехчастную структуру, в якій ви: встановлюєте деякий стан, запускаєте деяку одиницю коду і робите твердження про стані і виведення коду.

Якщо функції контрактів написані з використанням ``#[init(..)]`` або ``#[receive(..)]``, ми можемо протестувати ці функції безпосередньо в модульному тесті.

.. code-block:: rust

   use concordium_std::*;

   #[init(contract = "my_contract", payable, enable_logger)]
   fn contract_init(
      ctx: &impl HasInitContext<()>,
      amount: Amount,
      logger: &mut impl HasLogger,
   ) -> InitResult<State> { ... }

   #[receive(contract = "my_contract", name = "my_receive", payable, enable_logger)]
   fn contract_receive<A: HasActions>(
      ctx: &impl HasReceiveContext<()>,
      amount: Amount,
      logger: &mut impl HasLogger,
      state: &mut State,
   ) -> ReceiveResult<A> { ... }

Тестові заглушки для аргументів функції можна знайти в саб-модулі ``concordium-std`` під назвою ``test_infrastructure``.

.. seealso::

   For more information and examples see the crate documentation of
   concordium-std.

.. todo::

   Show more of how to write the unit test

Запуск тестів в Wasm
====================

Компіляція тестів в власний машинний код достатня для більшості випадків, але також можна скомпілювати тести в Wasm і запустити їх за допомогою точного інтерпретатора, що використовується вузлами.
Це робить тестову середу ближче до середовища запуску по ланцюжку і в деяких випадках може відловити більше помилок.

Інструмент розробки ``cargo-concordium`` включає в себе тестовий запуск для Wasm, який використовує той же Wasm-інтерпретатор, що і поставляється в вузлах Concordium.

.. seealso::

   For a guide of how to install ``cargo-concordium``, see :ref:`setup-tools`.

Модульний тест повинен бути анотований з ``#[concordium_test]`` замість ``#[test]``, і ми використовуємо ``#[concordium_cfg_test]`` замість ``#[cfg(test)]``:

.. code-block:: rust

   // contract code
   ...

   #[concordium_cfg_test]
   mod test {

       #[concordium_test]
       fn some_test() { ... }

       #[concordium_test]
       fn another_test() { ... }
   }

Макрос ``#[concordium_test]`` налаштовує наші тести для запуску в Wasm, коли ``concordium-std`` скомпільовано з функцією ``wasm-test``, і в іншому випадку повертається до поведінки як ``#[test]``, що означає, що все ще можна запустити модульні тести, націлені на нативний код, використовуючи ``cargo test``.

Аналогічно макрос ``#[concordium_cfg_test]`` включає наш модуль при складанні ``concordium-std`` з ``wasm-test`` в іншому випадку поводиться як ``#[test]``, дозволяючи нам контролювати, коли включати тести в збірку.

Тепер тести можна створювати і запускати, використовуючи:

.. code-block:: console

   $cargo concordium test

Ця команда компілює тести для Wasm з активним з'єднанням ``wasm-test`` для ``concordium-std`` і використовує засіб запуску тестів з ``cargo-concordium``.

.. warning::

   Повідомлення про помилки від ``panic!``, а, отже, і різні варіанти ``assert!``, не відображаються при компіляції в Wasm.

   Замість цього використовуйте ``fail!`` і ``claim!`` варіанти виконання тверджень при тестуванні, так як вони повертають повідомлення про помилки виконавцю тесту *перед* провалом тесту.
   Вони обидва є частиною ``concordium-std``.

.. todo::

   Use link concordium-std: docs.rs/concordium-std when crate is published.
